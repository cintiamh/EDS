// Generated by CoffeeScript 1.6.2
(function() {
  var ASPECT, BLOCK_SIZE, DEPTH, FAR, HEIGHT, NEAR, TABLE_DEPTH, TABLE_HEIGHT, TABLE_WIDTH, VIEW_ANGLE, WIDTH, block1, block2, block3, boundingBox, camera, canvas, createMovingBlock, createSolidBlock, moveBlockX, moveBlockY, moveBlockZ, render, renderer, scene, static_blocks;

  BLOCK_SIZE = 100;

  TABLE_WIDTH = 7;

  TABLE_HEIGHT = 7;

  TABLE_DEPTH = 15;

  WIDTH = BLOCK_SIZE * TABLE_WIDTH;

  HEIGHT = BLOCK_SIZE * TABLE_HEIGHT;

  DEPTH = BLOCK_SIZE * TABLE_DEPTH;

  VIEW_ANGLE = 45;

  ASPECT = WIDTH / HEIGHT;

  NEAR = 0.1;

  FAR = 10000;

  static_blocks = [];

  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);

  renderer = new THREE.WebGLRenderer();

  renderer.setSize(WIDTH, HEIGHT);

  canvas = $('#canvas');

  canvas.append(renderer.domElement);

  boundingBox = new THREE.Mesh(new THREE.CubeGeometry(WIDTH, HEIGHT, DEPTH * 2, TABLE_WIDTH, TABLE_HEIGHT, TABLE_DEPTH * 2), new THREE.MeshBasicMaterial({
    color: 0x999999,
    wireframe: true,
    wireframeLinewidth: 2
  }));

  scene.add(boundingBox);

  createMovingBlock = function() {
    var block;

    block = new THREE.SceneUtils.createMultiMaterialObject(new THREE.CubeGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), [
      new THREE.MeshBasicMaterial({
        color: 0xFFFFFF,
        wireframe: true,
        transparent: true
      }), new THREE.MeshBasicMaterial({
        color: 0xFFFFFF,
        transparent: true,
        opacity: 0.5
      })
    ]);
    scene.add(block);
    block.position.z = -0.5 * BLOCK_SIZE;
    return block;
  };

  createSolidBlock = function(x, y, z) {
    var block2, static_colors;

    static_colors = [0x00FFFF, 0x0000FF, 0x3333FF, 0x6565FF, 0x9999FF, 0xB2B2FF, 0xCBCBFF, 0xE5E5FF, 0xE5FFE5, 0xCBFFCB, 0xB2FFB2, 0x99FF99, 0x65FF65, 0x33FF33, 0x00FF00];
    block2 = new THREE.SceneUtils.createMultiMaterialObject(new THREE.CubeGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), [
      new THREE.MeshBasicMaterial({
        color: 0x000000,
        wireframe: true,
        transparent: true
      }), new THREE.MeshBasicMaterial({
        color: static_colors[Math.floor(Math.abs(z) / BLOCK_SIZE)]
      })
    ]);
    scene.add(block2);
    block2.position.x = x;
    block2.position.y = y;
    block2.position.z = z;
    return block2;
  };

  moveBlockX = function(block, value) {
    var temp;

    temp = block.position.x + value * BLOCK_SIZE;
    if (temp >= -3 * BLOCK_SIZE && temp <= 3 * BLOCK_SIZE) {
      return block.position.x = temp;
    }
  };

  moveBlockY = function(block, value) {
    var temp;

    temp = block.position.y + value * BLOCK_SIZE;
    if (temp >= -3 * BLOCK_SIZE && temp <= 3 * BLOCK_SIZE) {
      return block.position.y = temp;
    }
  };

  moveBlockZ = function(block) {
    var temp;

    temp = block.position.z - BLOCK_SIZE;
    if (temp >= -14.5 * BLOCK_SIZE) {
      return block.position.z = temp;
    }
  };

  block1 = createMovingBlock();

  block2 = createSolidBlock(BLOCK_SIZE * 3, BLOCK_SIZE * 3, -14.5 * BLOCK_SIZE);

  block3 = createSolidBlock(BLOCK_SIZE * 3, BLOCK_SIZE * 3, -0.5 * BLOCK_SIZE);

  window.$(document).ready(function() {
    return window.$(document).keydown(function(e) {
      switch (e.keyCode) {
        case 37:
        case 65:
          return moveBlockX(block1, -1);
        case 38:
        case 87:
          return moveBlockY(block1, 1);
        case 39:
        case 68:
          return moveBlockX(block1, 1);
        case 40:
          return moveBlockY(block1, -1);
        case 32:
          return moveBlockZ(block1);
      }
    });
  });

  camera.position.z = DEPTH - 54 - BLOCK_SIZE * 6;

  render = function() {
    requestAnimationFrame(render);
    return renderer.render(scene, camera);
  };

  render();

}).call(this);
