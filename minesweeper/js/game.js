// Generated by CoffeeScript 1.4.0
(function() {
  var BLOCK_SIZE, REFRESH_RATE, bombs, bombsList, callTimer, canvas, checkEndOfGame, context, convertNumToTimestamp, countBombs, discoverNeighbors, discoverTiles, drawBomb, drawCharacter, drawDownButton, drawFlag, drawLine, drawSquareBack, drawTable, drawUpButton, drawWrong, explodeBomb, exploded, findItemInList, fixDecimal, flagsList, flipPiece, flippedList, generateBombs, getMousePos, height, level, levelForm, levels, mousePos, numColors, prepareCanvas, putFlag, running, setFormListeners, setNewLevel, setNewLevelValue, start, tileNeighbors, time, updateBombs, width, won;

  BLOCK_SIZE = 30;

  REFRESH_RATE = 120;

  canvas = document.getElementById('game');

  context = canvas.getContext("2d");

  running = false;

  exploded = false;

  won = false;

  time = 0;

  level = 0;

  levels = [
    {
      x: 8,
      y: 8,
      bombs: 10
    }, {
      x: 16,
      y: 16,
      bombs: 40
    }, {
      x: 31,
      y: 16,
      bombs: 99
    }
  ];

  width = levels[level].x * BLOCK_SIZE;

  height = levels[level].y * BLOCK_SIZE;

  bombs = levels[level].bombs;

  bombsList = [];

  flagsList = [];

  flippedList = [];

  numColors = ["#0000FF", "#008040", "#FF0000", "#000080", "#800040", "#408080", "#000000", "#808080"];

  mousePos = {};

  tileNeighbors = function(inX, inY) {
    return [
      {
        x: inX - 1,
        y: inY - 1
      }, {
        x: inX - 1,
        y: inY
      }, {
        x: inX - 1,
        y: inY + 1
      }, {
        x: inX,
        y: inY - 1
      }, {
        x: inX,
        y: inY + 1
      }, {
        x: inX + 1,
        y: inY - 1
      }, {
        x: inX + 1,
        y: inY
      }, {
        x: inX + 1,
        y: inY + 1
      }
    ];
  };

  drawLine = function(startX, startY, endX, endY, color, lineWidth) {
    context.beginPath();
    context.moveTo(startX, startY);
    context.lineTo(endX, endY);
    context.lineWidth = lineWidth;
    context.strokeStyle = color;
    return context.stroke();
  };

  drawUpButton = function(x, y) {
    var lineWidth;
    drawSquareBack(x, y);
    lineWidth = 3;
    drawLine(x * BLOCK_SIZE, y * BLOCK_SIZE + lineWidth / 2, (x + 1) * BLOCK_SIZE, (y * BLOCK_SIZE) + lineWidth / 2, "#FFFFFF", lineWidth);
    drawLine(x * BLOCK_SIZE + lineWidth / 2, y * BLOCK_SIZE, x * BLOCK_SIZE + lineWidth / 2, (y + 1) * BLOCK_SIZE, "#FFFFFF", lineWidth);
    drawLine((x + 1) * BLOCK_SIZE - lineWidth / 2, (y + 1) * BLOCK_SIZE, (x + 1) * BLOCK_SIZE - lineWidth / 2, y * BLOCK_SIZE, "#7B7B7B", lineWidth);
    return drawLine((x + 1) * BLOCK_SIZE, (y + 1) * BLOCK_SIZE - lineWidth / 2, x * BLOCK_SIZE, (y + 1) * BLOCK_SIZE - lineWidth / 2, "#7B7B7B", lineWidth);
  };

  drawDownButton = function(x, y) {
    var lineWidth;
    drawSquareBack(x, y);
    lineWidth = 1;
    drawLine(x * BLOCK_SIZE, y * BLOCK_SIZE, (x + 1) * BLOCK_SIZE, y * BLOCK_SIZE, "#7B7B7B", lineWidth);
    drawLine(x * BLOCK_SIZE, y * BLOCK_SIZE, x * BLOCK_SIZE, (y + 1) * BLOCK_SIZE, "#7B7B7B", lineWidth);
    drawLine((x + 1) * BLOCK_SIZE, (y + 1) * BLOCK_SIZE, (x + 1) * BLOCK_SIZE, y * BLOCK_SIZE, "#7B7B7B", lineWidth);
    return drawLine((x + 1) * BLOCK_SIZE, (y + 1) * BLOCK_SIZE, x * BLOCK_SIZE, (y + 1) * BLOCK_SIZE, "#7B7B7B", lineWidth);
  };

  drawSquareBack = function(x, y) {
    context.beginPath();
    context.rect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    context.fillStyle = "#BDBDBD";
    return context.fill();
  };

  drawCharacter = function(x, y, v, color) {
    context.beginPath();
    context.font = "bold 18pt Arial";
    context.fillStyle = color;
    context.lineWidth = 2;
    return context.fillText(v, x * BLOCK_SIZE + 7, (y + 1) * BLOCK_SIZE - 6);
  };

  drawTable = function() {
    var posx, posy, _i, _ref, _results;
    context.beginPath();
    context.rect(0, 0, width, height);
    context.fillStyle = "#BDBDBD";
    context.fill();
    _results = [];
    for (posx = _i = 0, _ref = levels[level].x; 0 <= _ref ? _i <= _ref : _i >= _ref; posx = 0 <= _ref ? ++_i : --_i) {
      _results.push((function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (posy = _j = 0, _ref1 = levels[level].y; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; posy = 0 <= _ref1 ? ++_j : --_j) {
          _results1.push(drawUpButton(posx, posy));
        }
        return _results1;
      })());
    }
    return _results;
  };

  drawBomb = function(x, y) {
    context.beginPath();
    context.arc((x + 0.5) * BLOCK_SIZE, (y + 0.5) * BLOCK_SIZE, BLOCK_SIZE * 0.3, 0, 2 * Math.PI, false);
    context.fillStyle = "#000000";
    context.fill();
    context.moveTo((x + 0.5) * BLOCK_SIZE, (y + 0.05) * BLOCK_SIZE);
    context.lineTo((x + 0.5) * BLOCK_SIZE, (y + 0.95) * BLOCK_SIZE);
    context.moveTo((x + 0.05) * BLOCK_SIZE, (y + 0.5) * BLOCK_SIZE);
    context.lineTo((x + 0.95) * BLOCK_SIZE, (y + 0.5) * BLOCK_SIZE);
    context.moveTo((x + 0.16) * BLOCK_SIZE, (y + 0.16) * BLOCK_SIZE);
    context.lineTo((x + 0.83) * BLOCK_SIZE, (y + 0.83) * BLOCK_SIZE);
    context.moveTo((x + 0.83) * BLOCK_SIZE, (y + 0.16) * BLOCK_SIZE);
    context.lineTo((x + 0.16) * BLOCK_SIZE, (y + 0.83) * BLOCK_SIZE);
    context.lineWidth = 2;
    context.strokeStyle = "#000000";
    context.stroke();
    context.beginPath();
    context.arc((x + 0.35) * BLOCK_SIZE, (y + 0.35) * BLOCK_SIZE, BLOCK_SIZE * 0.1, 0, 2 * Math.PI, false);
    context.fillStyle = "#FFFFFF";
    return context.fill();
  };

  drawWrong = function(x, y) {
    context.beginPath();
    context.moveTo(x * BLOCK_SIZE, y * BLOCK_SIZE);
    context.lineTo((x + 1) * BLOCK_SIZE, (y + 1) * BLOCK_SIZE);
    context.moveTo((x + 1) * BLOCK_SIZE, y * BLOCK_SIZE);
    context.lineTo(x * BLOCK_SIZE, (y + 1) * BLOCK_SIZE);
    context.lineWidth = 2;
    context.strokeStyle = "#FF0000";
    return context.stroke();
  };

  drawFlag = function(x, y) {
    context.beginPath();
    context.moveTo((x + 0.5) * BLOCK_SIZE, (y + 0.5) * BLOCK_SIZE);
    context.lineTo((x + 0.5) * BLOCK_SIZE, (y + 0.9) * BLOCK_SIZE);
    context.lineWidth = 2;
    context.strokeStyle = "#000000";
    context.stroke();
    context.beginPath();
    context.moveTo((x + 0.55) * BLOCK_SIZE, (y + 0.1) * BLOCK_SIZE);
    context.lineTo((x + 0.55) * BLOCK_SIZE, (y + 0.55) * BLOCK_SIZE);
    context.lineTo((x + 0.1) * BLOCK_SIZE, (y + 0.3) * BLOCK_SIZE);
    context.closePath();
    context.fillStyle = "#FF0000";
    context.fill();
    context.beginPath();
    context.moveTo((x + 0.4) * BLOCK_SIZE, (y + 0.7) * BLOCK_SIZE);
    context.lineTo((x + 0.6) * BLOCK_SIZE, (y + 0.7) * BLOCK_SIZE);
    context.lineTo((x + 0.6) * BLOCK_SIZE, (y + 0.8) * BLOCK_SIZE);
    context.lineTo((x + 0.4) * BLOCK_SIZE, (y + 0.8) * BLOCK_SIZE);
    context.closePath();
    context.fillStyle = "#000000";
    context.fill();
    context.beginPath();
    context.moveTo((x + 0.3) * BLOCK_SIZE, (y + 0.8) * BLOCK_SIZE);
    context.lineTo((x + 0.7) * BLOCK_SIZE, (y + 0.8) * BLOCK_SIZE);
    context.lineTo((x + 0.7) * BLOCK_SIZE, (y + 0.9) * BLOCK_SIZE);
    context.lineTo((x + 0.3) * BLOCK_SIZE, (y + 0.9) * BLOCK_SIZE);
    context.closePath();
    context.fillStyle = "#000000";
    return context.fill();
  };

  getMousePos = function(canvas, evt) {
    var rect;
    rect = canvas.getBoundingClientRect();
    return {
      x: Math.floor((evt.clientX - rect.left) / BLOCK_SIZE),
      y: Math.floor((evt.clientY - rect.top) / BLOCK_SIZE)
    };
  };

  canvas.addEventListener('click', function(evt) {
    evt.preventDefault();
    mousePos = getMousePos(canvas, evt);
    if (!(exploded || won)) {
      flipPiece(mousePos.x, mousePos.y);
    }
    return false;
  }, false);

  canvas.addEventListener('contextmenu', function(evt) {
    evt.preventDefault();
    mousePos = getMousePos(canvas, evt);
    if (!(exploded || won)) {
      putFlag(mousePos.x, mousePos.y);
    }
    return false;
  }, false);

  flipPiece = function(x, y) {
    if (!running) {
      start();
      generateBombs(x, y);
    }
    if (!((findItemInList(flagsList, x, y)) || exploded)) {
      if (findItemInList(bombsList, x, y)) {
        return explodeBomb();
      } else {
        return discoverTiles(x, y);
      }
    }
  };

  discoverTiles = function(x, y) {
    var count;
    if (!(findItemInList(flippedList, x, y) || findItemInList(bombsList, x, y))) {
      drawDownButton(x, y);
      count = countBombs(x, y);
      flippedList.push({
        x: x,
        y: y
      });
      if (count === 0) {
        return discoverNeighbors(x, y);
      } else {
        return drawCharacter(x, y, count, numColors[count - 1]);
      }
    }
  };

  explodeBomb = function() {
    exploded = true;
    document.getElementById("message").innerHTML = "You just exploded!!!";
    bombsList.map(function(bomb) {
      if (!findItemInList(flagsList, bomb.x, bomb.y)) {
        drawDownButton(bomb.x, bomb.y);
        return drawBomb(bomb.x, bomb.y);
      }
    });
    return flagsList.map(function(flag) {
      if (!findItemInList(bombsList, flag.x, flag.y)) {
        drawUpButton(flag.x, flag.y);
        drawBomb(flag.x, flag.y);
        return drawWrong(flag.x, flag.y);
      }
    });
  };

  discoverNeighbors = function(x, y) {
    return tileNeighbors(x, y).map(function(tile) {
      var _ref, _ref1;
      if ((0 <= (_ref = tile.x) && _ref < levels[level].x) && (0 <= (_ref1 = tile.y) && _ref1 < levels[level].y) && !findItemInList(flagsList, tile.x, tile.y)) {
        return discoverTiles(tile.x, tile.y);
      }
    });
  };

  countBombs = function(x, y) {
    var count;
    count = 0;
    tileNeighbors(x, y).map(function(tile) {
      var _ref, _ref1;
      if ((0 <= (_ref = tile.x) && _ref < levels[level].x) && (0 <= (_ref1 = tile.y) && _ref1 < levels[level].y)) {
        if (findItemInList(bombsList, tile.x, tile.y)) {
          return count++;
        }
      }
    });
    return count;
  };

  putFlag = function(x, y) {
    var flag, temp, _i, _len;
    if (!findItemInList(flippedList, x, y)) {
      if (findItemInList(flagsList, x, y)) {
        temp = [];
        for (_i = 0, _len = flagsList.length; _i < _len; _i++) {
          flag = flagsList[_i];
          if (!(flag.x === x && flag.y === y)) {
            temp.push(flag);
          }
        }
        flagsList = temp;
        drawSquareBack(x, y);
        return drawUpButton(x, y);
      } else {
        flagsList.push({
          x: x,
          y: y
        });
        drawFlag(x, y);
        bombs--;
        if (checkEndOfGame()) {
          won = true;
          document.getElementById("message").innerHTML = "Congratulations!!! You WON!!!";
        }
        return updateBombs();
      }
    }
  };

  checkEndOfGame = function() {
    if (bombsList.length === flagsList.length) {
      flagsList.map(function(flag) {
        if (!findItemInList(bombsList, flag.x, flag.y)) {
          return false;
        }
      });
      return true;
    }
    return false;
  };

  setNewLevel = function(l) {
    if (l < levels.length) {
      level = l;
      width = levels[level].x * BLOCK_SIZE;
      height = levels[level].y * BLOCK_SIZE;
      bombs = levels[level].bombs;
      canvas.width = width;
      canvas.height = height;
      return updateBombs();
    }
  };

  generateBombs = function(x, y) {
    var newX, newY;
    bombsList = [];
    bombs = 0;
    while (bombs < levels[level].bombs) {
      newX = Math.floor(Math.random() * levels[level].x);
      newY = Math.floor(Math.random() * levels[level].y);
      if (!(findItemInList(bombsList, newX, newY) || (newX === x && newY === y))) {
        bombsList.push({
          x: newX,
          y: newY
        });
        bombs++;
      }
    }
    return updateBombs();
  };

  findItemInList = function(list, x, y) {
    var item, _i, _len;
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      item = list[_i];
      if (item.x === x && item.y === y) {
        return true;
      }
    }
    return false;
  };

  start = function() {
    running = true;
    return updateBombs();
  };

  /*
    Controlling external elements
    - Level Select
    - Remaining Bombs #
    - Clock
  */


  updateBombs = function() {
    if (bombs >= 0) {
      return document.getElementById("bombs").innerHTML = bombs;
    }
  };

  callTimer = function() {
    if (running && !exploded && !won) {
      time++;
      return document.getElementById("time").innerHTML = convertNumToTimestamp(time);
    }
  };

  convertNumToTimestamp = function(t) {
    var hor, min, sec;
    sec = fixDecimal(Math.floor(t % 60));
    min = fixDecimal(Math.floor(t / 60));
    hor = fixDecimal(Math.floor(t / (60 * 60)));
    return "" + hor + ":" + min + ":" + sec;
  };

  fixDecimal = function(n) {
    if (!(n >= 10)) {
      return "0" + n;
    }
    return n;
  };

  window.setInterval(callTimer, 1000);

  levelForm = "";

  setFormListeners = function() {
    levelForm = document.getElementById("levelBtn");
    return levelForm.addEventListener("click", setNewLevelValue);
  };

  setNewLevelValue = function() {
    var levelSel;
    levelSel = document.getElementById("levelSel");
    level = parseInt(levelSel.value);
    return prepareCanvas();
  };

  prepareCanvas = function() {
    document.getElementById("message").innerHTML = "";
    document.getElementById("time").innerHTML = convertNumToTimestamp(0);
    running = false;
    exploded = false;
    won = false;
    time = 0;
    bombs = levels[level].bombs;
    bombsList = [];
    flagsList = [];
    flippedList = [];
    setNewLevel(level);
    drawTable();
    return setFormListeners();
  };

  prepareCanvas();

}).call(this);
