// Generated by CoffeeScript 1.4.0
(function() {
  var BLOCK_SIZE, REFRESH_RATE, bombs, bombsList, callTimer, canvas, context, convertNumToTimestamp, countBombs, discoverNeighbors, discoverTiles, drawCharacter, drawDownButton, drawLine, drawSquareBack, drawTable, drawUpButton, explodeBomb, exploded, findItemInList, fixDecimal, flagsList, flipPiece, flippedList, generateBombs, getMousePos, height, level, levels, mousePos, numColors, prepareCanvas, putFlag, running, setNewLevel, start, tileNeighbors, time, updateBombs, width;

  BLOCK_SIZE = 30;

  REFRESH_RATE = 120;

  canvas = document.getElementById('game');

  context = canvas.getContext("2d");

  running = false;

  exploded = false;

  time = 0;

  level = 0;

  levels = [
    {
      x: 8,
      y: 8,
      bombs: 10
    }, {
      x: 16,
      y: 16,
      bombs: 40
    }, {
      x: 31,
      y: 16,
      bombs: 99
    }
  ];

  width = levels[level].x * BLOCK_SIZE;

  height = levels[level].y * BLOCK_SIZE;

  bombs = levels[level].bombs;

  bombsList = [];

  flagsList = [];

  flippedList = [];

  numColors = ["#0000FF", "#008040", "#FF0000", "#000080", "#800040", "#408080", "#000000", "#808080"];

  mousePos = {};

  tileNeighbors = function(inX, inY) {
    return [
      {
        x: inX - 1,
        y: inY - 1
      }, {
        x: inX - 1,
        y: inY
      }, {
        x: inX - 1,
        y: inY + 1
      }, {
        x: inX,
        y: inY - 1
      }, {
        x: inX,
        y: inY + 1
      }, {
        x: inX + 1,
        y: inY - 1
      }, {
        x: inX + 1,
        y: inY
      }, {
        x: inX + 1,
        y: inY + 1
      }
    ];
  };

  drawLine = function(startX, startY, endX, endY, color, lineWidth) {
    context.beginPath();
    context.moveTo(startX, startY);
    context.lineTo(endX, endY);
    context.lineWidth = lineWidth;
    context.strokeStyle = color;
    return context.stroke();
  };

  drawUpButton = function(x, y) {
    var lineWidth;
    drawSquareBack(x, y);
    lineWidth = 3;
    drawLine(x * BLOCK_SIZE, y * BLOCK_SIZE + lineWidth / 2, (x + 1) * BLOCK_SIZE, (y * BLOCK_SIZE) + lineWidth / 2, "#FFFFFF", lineWidth);
    drawLine(x * BLOCK_SIZE + lineWidth / 2, y * BLOCK_SIZE, x * BLOCK_SIZE + lineWidth / 2, (y + 1) * BLOCK_SIZE, "#FFFFFF", lineWidth);
    drawLine((x + 1) * BLOCK_SIZE - lineWidth / 2, (y + 1) * BLOCK_SIZE, (x + 1) * BLOCK_SIZE - lineWidth / 2, y * BLOCK_SIZE, "#7B7B7B", lineWidth);
    return drawLine((x + 1) * BLOCK_SIZE, (y + 1) * BLOCK_SIZE - lineWidth / 2, x * BLOCK_SIZE, (y + 1) * BLOCK_SIZE - lineWidth / 2, "#7B7B7B", lineWidth);
  };

  drawDownButton = function(x, y) {
    var lineWidth;
    drawSquareBack(x, y);
    lineWidth = 1;
    drawLine(x * BLOCK_SIZE, y * BLOCK_SIZE, (x + 1) * BLOCK_SIZE, y * BLOCK_SIZE, "#7B7B7B", lineWidth);
    drawLine(x * BLOCK_SIZE, y * BLOCK_SIZE, x * BLOCK_SIZE, (y + 1) * BLOCK_SIZE, "#7B7B7B", lineWidth);
    drawLine((x + 1) * BLOCK_SIZE, (y + 1) * BLOCK_SIZE, (x + 1) * BLOCK_SIZE, y * BLOCK_SIZE, "#7B7B7B", lineWidth);
    return drawLine((x + 1) * BLOCK_SIZE, (y + 1) * BLOCK_SIZE, x * BLOCK_SIZE, (y + 1) * BLOCK_SIZE, "#7B7B7B", lineWidth);
  };

  drawSquareBack = function(x, y) {
    context.beginPath();
    context.rect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    context.fillStyle = "#BDBDBD";
    return context.fill();
  };

  drawCharacter = function(x, y, v, color) {
    context.beginPath();
    context.font = "bold 18pt Arial";
    context.fillStyle = color;
    context.lineWidth = 2;
    return context.fillText(v, x * BLOCK_SIZE + 7, (y + 1) * BLOCK_SIZE - 6);
  };

  drawTable = function() {
    var posx, posy, _i, _ref, _results;
    context.beginPath();
    context.rect(0, 0, width, height);
    context.fillStyle = "#BDBDBD";
    context.fill();
    _results = [];
    for (posx = _i = 0, _ref = levels[level].x; 0 <= _ref ? _i <= _ref : _i >= _ref; posx = 0 <= _ref ? ++_i : --_i) {
      _results.push((function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (posy = _j = 0, _ref1 = levels[level].y; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; posy = 0 <= _ref1 ? ++_j : --_j) {
          _results1.push(drawUpButton(posx, posy));
        }
        return _results1;
      })());
    }
    return _results;
  };

  getMousePos = function(canvas, evt) {
    var rect;
    rect = canvas.getBoundingClientRect();
    return {
      x: Math.floor((evt.clientX - rect.left) / BLOCK_SIZE),
      y: Math.floor((evt.clientY - rect.top) / BLOCK_SIZE)
    };
  };

  canvas.addEventListener('click', function(evt) {
    evt.preventDefault();
    mousePos = getMousePos(canvas, evt);
    flipPiece(mousePos.x, mousePos.y);
    return false;
  }, false);

  canvas.addEventListener('contextmenu', function(evt) {
    evt.preventDefault();
    mousePos = getMousePos(canvas, evt);
    putFlag(mousePos.x, mousePos.y);
    return false;
  }, false);

  flipPiece = function(x, y) {
    if (!running) {
      start();
      generateBombs(x, y);
    }
    if (!((findItemInList(flagsList, x, y)) || exploded)) {
      if (findItemInList(bombsList, x, y)) {
        return explodeBomb();
      } else {
        return discoverTiles(x, y);
      }
    }
  };

  discoverTiles = function(x, y) {
    var count;
    if (!(findItemInList(flippedList, x, y) || findItemInList(bombsList, x, y))) {
      drawDownButton(x, y);
      count = countBombs(x, y);
      flippedList.push({
        x: x,
        y: y
      });
      if (count === 0) {
        return discoverNeighbors(x, y);
      } else {
        return drawCharacter(x, y, count, numColors[count - 1]);
      }
    }
  };

  explodeBomb = function() {
    exploded = true;
    return bombsList.map(function(bomb) {
      drawDownButton(bomb.x, bomb.y);
      return drawCharacter(bomb.x, bomb.y, "B", "#000000");
    });
  };

  discoverNeighbors = function(x, y) {
    return tileNeighbors(x, y).map(function(tile) {
      var _ref, _ref1;
      if ((0 <= (_ref = tile.x) && _ref < levels[level].x) && (0 <= (_ref1 = tile.y) && _ref1 < levels[level].y)) {
        return discoverTiles(tile.x, tile.y);
      }
    });
  };

  countBombs = function(x, y) {
    var count;
    count = 0;
    tileNeighbors(x, y).map(function(tile) {
      var _ref, _ref1;
      if ((0 <= (_ref = tile.x) && _ref < levels[level].x) && (0 <= (_ref1 = tile.y) && _ref1 < levels[level].y)) {
        if (findItemInList(bombsList, tile.x, tile.y)) {
          return count++;
        }
      }
    });
    return count;
  };

  putFlag = function(x, y) {
    var flag, temp, _i, _len;
    if (!findItemInList(flippedList, x, y)) {
      if (findItemInList(flagsList, x, y)) {
        temp = [];
        for (_i = 0, _len = flagsList.length; _i < _len; _i++) {
          flag = flagsList[_i];
          if (!(flag.x === x && flag.y === y)) {
            temp.push(flag);
          }
        }
        flagsList = temp;
        drawSquareBack(x, y);
        return drawUpButton(x, y);
      } else {
        flagsList.push({
          x: x,
          y: y
        });
        drawCharacter(x, y, "F", "#FF0000");
        bombs--;
        return updateBombs();
      }
    }
  };

  setNewLevel = function(l) {
    if (l < levels.length) {
      level = l;
      width = levels[level].x * BLOCK_SIZE;
      height = levels[level].y * BLOCK_SIZE;
      bombs = levels[level].bombs;
      canvas.width = width;
      return canvas.height = height;
    }
  };

  generateBombs = function(x, y) {
    var newX, newY;
    bombsList = [];
    bombs = 0;
    while (bombs < levels[level].bombs) {
      newX = Math.floor(Math.random() * levels[level].x);
      newY = Math.floor(Math.random() * levels[level].y);
      if (!(findItemInList(bombsList, newX, newY) || (newX === x && newY === y))) {
        bombsList.push({
          x: newX,
          y: newY
        });
        bombs++;
      }
    }
    return updateBombs();
  };

  findItemInList = function(list, x, y) {
    var item, _i, _len;
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      item = list[_i];
      if (item.x === x && item.y === y) {
        return true;
      }
    }
    return false;
  };

  start = function() {
    running = true;
    return flagsList = [];
  };

  prepareCanvas = function() {
    setNewLevel(level);
    return drawTable();
  };

  prepareCanvas();

  setInterval(callTimer, 1000);

  /*
    Controlling external elements
    - Level Select
    - Remaining Bombs #
    - Clock
  */


  updateBombs = function() {
    console.log("updateBombs: " + bombs);
    if (bombs >= 0) {
      return document.getElementById("bombs").innerHTML = bombs;
    }
  };

  callTimer = function() {
    if (running) {
      time++;
      return document.getElementById("time").innerHTML = convertNumToTimestamp(time);
    }
  };

  convertNumToTimestamp = function(t) {
    var hor, min, sec;
    sec = fixDecimal(Math.floor(t % 60));
    min = fixDecimal(Math.floor(t / 60));
    hor = fixDecimal(Math.floor(t / (60 * 60)));
    return "" + hor + ":" + min + ":" + sec;
  };

  fixDecimal = function(n) {
    if (!(n >= 10)) {
      return "0" + n;
    }
    return n;
  };

  window.setInterval(callTimer, 1000);

}).call(this);
